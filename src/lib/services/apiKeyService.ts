import { PrismaClient } from '@prisma/client';
import prisma from '../db/prisma';
import { encrypt, decrypt } from '../utils/encryption';

// Define the shape of ApiKey type since it's now generated by Prisma
export type ApiKey = {
  id: string;
  name: string;
  service: string;
  key: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt: Date;
  userId: string;
};

export type ApiKeyCreateInput = {
  name: string;
  service: string;
  key: string;
  userId: string;
};

export type ApiKeyUpdateInput = {
  name?: string;
  key?: string;
  isActive?: boolean;
};

// In-memory storage for MVP when database operations fail
const inMemoryApiKeys: Record<string, Record<string, string>> = {};

/**
 * Create a new API key
 * This function encrypts the key (pass-through in MVP)
 */
export const createApiKey = async (data: {
  name: string;
  service: string;
  key: string;
  userId: string;
}): Promise<ApiKey> => {
  // In MVP, this is a pass-through operation (no actual encryption)
  const encryptedKey = encrypt(data.key);
  
  try {
    // Attempt to check if user exists first
    const userExists = await prisma.user.findUnique({
      where: { id: data.userId },
    });
    
    // If user doesn't exist and this is not a test ID, create a mock user for MVP
    if (!userExists && data.userId !== 'test-user-id') {
      try {
        await prisma.user.create({
          data: {
            id: data.userId,
            email: `user-${data.userId}@example.com`,
            emailVerified: new Date(),
            name: `User ${data.userId}`,
          },
        });
        console.log(`Created mock user for ${data.userId}`);
      } catch (userCreateError) {
        console.error('Failed to create mock user:', userCreateError);
        // Continue with fallback approach
      }
    }
    
    // Create the API key in the database
    return await prisma.apiKey.create({
      data: {
        name: data.name,
        service: data.service,
        key: encryptedKey,
        isActive: true,
        user: {
          connect: {
            id: data.userId,
          },
        },
      },
    });
  } catch (error) {
    console.error('Error creating API key in database:', error);
    
    // Fallback to in-memory storage for MVP
    console.log('Using in-memory storage fallback for API key');
    
    if (!inMemoryApiKeys[data.userId]) {
      inMemoryApiKeys[data.userId] = {};
    }
    
    inMemoryApiKeys[data.userId][data.service] = data.key;
    
    // Return a mock API key object
    return {
      id: `memory-${Date.now()}`,
      name: data.name,
      service: data.service,
      key: encryptedKey,
      isActive: true,
      createdAt: new Date(),
      updatedAt: new Date(),
      userId: data.userId,
    };
  }
};

/**
 * Get all API keys for a user
 * Note: This doesn't return the decrypted keys for security
 */
export const getApiKeys = async (userId: string): Promise<ApiKey[]> => {
  return prisma.apiKey.findMany({
    where: {
      userId,
    },
    orderBy: {
      createdAt: 'desc',
    },
  });
};

/**
 * Get a specific API key by ID
 * Optionally decrypt the key (pass-through in MVP)
 */
export const getApiKey = async (
  id: string,
  shouldDecrypt = false
): Promise<ApiKey | null> => {
  try {
    const apiKey = await prisma.apiKey.findUnique({
      where: {
        id,
      },
    });

    if (!apiKey) return null;

    // If requested, decrypt the key before returning
    // In MVP, this is a pass-through operation
    if (shouldDecrypt) {
      return {
        ...apiKey,
        key: decrypt(apiKey.key),
      };
    }

    return apiKey;
  } catch (error) {
    console.error('Error retrieving API key:', error);
    return null;
  }
};

/**
 * Get an active API key for a specific service by user ID
 * Always decrypts the key for use (pass-through in MVP)
 */
export const getActiveApiKeyForService = async (
  userId: string,
  service: string
): Promise<string | null> => {
  try {
    // First check in-memory storage for MVP
    if (inMemoryApiKeys[userId] && inMemoryApiKeys[userId][service]) {
      console.log(`Using in-memory ${service} API key for user ${userId}`);
      return inMemoryApiKeys[userId][service];
    }
    
    const apiKey = await prisma.apiKey.findFirst({
      where: {
        userId,
        service,
        isActive: true,
      },
      orderBy: {
        createdAt: 'desc',
      },
    });

    if (!apiKey) return null;
    
    // Decrypt the key for use (pass-through in MVP)
    return decrypt(apiKey.key);
  } catch (error) {
    console.error(`Error retrieving ${service} API key:`, error);
    
    // Check in-memory storage as fallback
    if (inMemoryApiKeys[userId] && inMemoryApiKeys[userId][service]) {
      console.log(`Falling back to in-memory ${service} API key for user ${userId}`);
      return inMemoryApiKeys[userId][service];
    }
    
    return null;
  }
};

/**
 * Update an API key
 * NOTE: In MVP, encryption is simplified (pass-through)
 */
export const updateApiKey = async (
  id: string,
  data: ApiKeyUpdateInput
): Promise<ApiKey> => {
  const updateData: any = { ...data };
  
  // If key is being updated, encrypt it
  // In MVP, this is a pass-through operation
  if (data.key) {
    updateData.key = encrypt(data.key);
  }
  
  return prisma.apiKey.update({
    where: {
      id,
    },
    data: updateData,
  });
};

/**
 * Delete an API key
 */
export const deleteApiKey = async (id: string): Promise<ApiKey> => {
  return prisma.apiKey.delete({
    where: {
      id,
    },
  });
}; 